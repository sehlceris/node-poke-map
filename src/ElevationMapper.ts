let gmaps = require('@google/maps');
let fs = require('fs');
import Config from './Config';
import Data from './Data';
import Utils from './Utils';
import Constants from './Constants';

const log:any = Utils.getLogger('ElevationMapper');

const LOCATIONS_PER_REQUEST = 128;
const DELAY_BETWEEN_REQUESTS = 3000;
const ELEVATION_JSON_KEY = 'elevation';
const MAXIMUM_LAT_DIFF_FOR_MATCH = 0.0000000000001;
const MAXIMUM_LONG_DIFF_FOR_MATCH = 0.000000000001;

/**
 * A standalone application that takes a spawn JSON generated by TBTerra's SpawnScan and outputs a new file containing the original spawnpoints and the elevations each spawnpoint rests on. This is done to convince the Niantic server that our given GPS location is real
 */
export default class ElevationMapper {

    spawnsJson:any; //array of spawnpoints, read from JSON
    gmapsApiKey:String; //google maps API key
    gmapsClient:any; //google maps client
    segments:any; //array of arrays, each representing a segment of spawnpoints to map elevetions for
    segmentIndex:Number; //current segment of spawnpoints that we are mapping elevations for

    /**
     * Creates the elevation mapper
     */
    constructor() {
        this.gmapsApiKey = Config.googleMapsApiKey;
        this.spawnsJson = Data.getSpawns();
        this.gmapsClient = gmaps.createClient({
            key: this.gmapsApiKey
        });
    }

    /**
     * Takes the input spawnpoint JSON, populates it with elevation data, and then writes it out to a file
     * @returns {Promise<void>}
     */
    execute():Promise {

        //Only process spawnpoints that don't already have elevation data
        let filteredSpawns = this.spawnsJson.filter((spawn) => {
            return (typeof(spawn[ELEVATION_JSON_KEY]) !== 'number');
        });

        //Segment the spawnpoint data into chunks (Google only allows a certain number of elevations to be mapped per API call)
        let segments = this.segmentLocations(filteredSpawns);
        log.info(`segmented data into ${segments.length} requests...`);

        //Kicks off the process to add elevation data to all the segments
        this.segments = segments;
        this.segmentIndex = 0;
        return this.process()
            .then(() => {
                log.info(`all segments processed`);
                log.info(`writing spawns json at ${Constants.SPAWNS_WITH_ELEVATIONS_JSON_PATH}`);
                this.writeJson(this.spawnsJson);
                log.info(`write complete`);
            });
    }

    /**
     * Loops through all spawnpoint segments and populates them with elevation data
     * @returns {Promise<void>}
     */
    process():Promise {
        log.info(`processing segment ${this.segmentIndex}`);
        return this.populateSegmentData(this.segments[this.segmentIndex], this.segmentIndex)
            .then(() => {
                //Delay the next execution to be nice to Google API server
                return new Promise((resolve, reject) => {
                    setTimeout(resolve, DELAY_BETWEEN_REQUESTS);
                })
            })
            .then(() => {
                //If we still have segments to process, redo the loop
                log.info(`processed segment ${this.segmentIndex}`);
                if (this.segmentIndex < this.segments.length - 1) {
                    this.segmentIndex++;
                    return this.process();
                }
            })
            .catch((err) => {
                log.info(`failed to process segment ${this.segmentIndex}: ${err}; continuing...`);
                if (this.segmentIndex < this.segments.length - 1) {
                    this.segmentIndex++;
                    return this.process();
                }
            })
    }

    /**
     * Segments the spawns array into an array of segments to be processed
     * @param {Array} spawns Spawnpoint array
     * @returns {Array<Array>} Array of arrays, each first-level array representing a segment of spawnpoints
     */
    segmentLocations(spawns:Array):Array<Array> {

        let segments = [];

        let i;
        let j;
        let tempArray;
        for (i = 0, j = spawns.length; i < j; i += LOCATIONS_PER_REQUEST) {
            tempArray = spawns.slice(i, i + LOCATIONS_PER_REQUEST);
            segments.push(tempArray);
        }

        return segments;
    }

    /**
     *  Make the elevation request for the specified segment, and add all the elevations into the original spawn json
     * @param {Array} segment Array of spawnpoints to process
     * @param {Number} segmentIndex Current segment number being processed
     * @returns {Promise<void>}
     */
    populateSegmentData(segment, segmentIndex):Promise {
        let spawnLatLongs = segment.map((spawn) => {
            return {
                lat: spawn.lat,
                lng: spawn.lng
            };
        });

        log.info(`making request for segment ${segmentIndex}`);
        try {
            return new Promise((resolve, reject) => {
                this.gmapsClient.elevation({
                    locations: spawnLatLongs
                }, (err, result) => {
                    if (err) {
                        return reject(err);
                    }
                    else if (result.json && result.json.results && result.json.results.length && result.json.status === 'OK') {
                        return resolve(result.json.results);
                    }
                    else {
                        return reject(`results are in an unrecognized format. ${JSON.stringify(result)}`)
                    }
                });
            })
                .then((results) => {
                    log.info(`segment ${segmentIndex} elevation service returned results. processing results, please wait... `);
                    //log.info(JSON.stringify(results));

                    results.forEach((result) => {
                        if (result.elevation && result.location) {
                            let spawn = this.spawnsJson.find((spawn) => {

                                if (typeof(spawn[ELEVATION_JSON_KEY]) === 'number') {
                                    return false;
                                }

                                //Google doesn't return the exact lat/lng that you gave it - you need to allow some fudge space
                                let diffLat = Math.abs(result.location.lat - spawn.lat);
                                let diffLong = Math.abs(result.location.lng - spawn.lng);

                                let match = ((diffLat <= MAXIMUM_LAT_DIFF_FOR_MATCH) && (diffLong <= MAXIMUM_LONG_DIFF_FOR_MATCH));

                                //log.info(`diffLat: ${diffLat}; diffLong: ${diffLong}; match = ${match}`);

                                return match
                            });
                            if (!spawn) {
                                log.error(`segment ${segmentIndex} failed insert result for spawn at ${result.location.lat}, ${result.location.lng} - no match`);
                            }
                            else {
                                spawn[ELEVATION_JSON_KEY] = result.elevation;
                            }
                        }
                    });

                    log.info(`processed results for segment ${segmentIndex}/${this.segments.length - 1}`);
                })
                .catch((err) => {
                    log.error(`segment ${segmentIndex} elevation service returned error: ${err}`);
                });
        }
        catch (e) {
            let message = `caught exception while making request for segment ${segmentIndex}: ${e}`;
            log.error(message);
            return Promise.reject(message);
        }
    }

    /**
     * Writes the spawnpoint data into a json file
     * @param {Object} data Spawnpoint data
     */
    writeJson(data):void {
        fs.writeFileSync(Constants.SPAWNS_WITH_ELEVATIONS_JSON_PATH, JSON.stringify(data));
    }
}

let mapper = new ElevationMapper();
log.info(`mapping elevations...`);
mapper.execute()
    .then(() => {
        //Successfully wrote elevations!
        process.exit(0);
    })
    .catch((err) => {
        log.error(`failed to write data: ${err}`);
        setTimeout(() => {
            process.exit(1);
        }, 500);
    })